let styles = """
.board {
  display: flex;
  flex-wrap: wrap;
  width: 500px;
  margin: 50px auto;
}

.cell {
  box-sizing: border-box;
  width: 50px;
  height: 50px;
  border: 1px solid black;
  background: white;
}

.cell-right { border-right-color: #e9e9e9; }
.cell-left { border-left-color: #e9e9e9; }
.cell-top { border-top-color: #e9e9e9; }
.cell-bottom { border-bottom-color: #e9e9e9; }

.cell-visited { background: #e9e9e9; }
.cell-current { background: red; }
"""

let grid = [ repeat [ repeat 0 5 ] 100 ]
let current = 0

--
function getUnvisitedNeighbors(pos) {
  let neighbors = [];

  if (!isVisited({ x: pos.x - 1, y: pos.y })) neighbors.push('left');
  if (!isVisited({ x: pos.x + 1, y: pos.y })) neighbors.push('right');
  if (!isVisited({ x: pos.x, y: pos.y - 1 })) neighbors.push('top');
  if (!isVisited({ x: pos.x, y: pos.y + 1 })) neighbors.push('bottom');

  return neighbors;
}

function isVisited (pos) {
  if (pos.x < 0 || pos.x >= 10) return true;
  if (pos.y < 0 || pos.y >= 10) return true;
  return grid[pos.x + (pos.y * 10)][4] === 1;
}

function setVisited (pos, dir) {
  let newpos = { x: pos.x, y: pos.y };
  switch (dir) {
    case 'left':
      newpos.x -= 1;
      grid[newpos.x + (newpos.y * 10)][1] = 1;
      grid[pos.x + (pos.y * 10)][3] = 1;
      break;
    case 'top': 
      newpos.y -= 1;
      grid[newpos.x + (newpos.y * 10)][2] = 1;
      grid[pos.x + (pos.y * 10)][0] = 1;
      break;
    case 'right':
      newpos.x += 1;
      grid[newpos.x + (newpos.y * 10)][3] = 1;
      grid[pos.x + (pos.y * 10)][1] = 1;
      break;
    case 'bottom':
      newpos.y += 1;
      grid[newpos.x + (newpos.y * 10)][0] = 1;
      grid[pos.x + (pos.y * 10)][2] = 1;
      break;
  }
  grid[newpos.x + (newpos.y * 10)][4] = 1;
  return newpos;
}

async function wait (ms) {
  return new Promise ((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}

function resetGrid () {
  for (let i = 0; i < 100; i++) {
    grid[i][0] = 0;
    grid[i][1] = 0;
    grid[i][2] = 0;
    grid[i][3] = 0;
    grid[i][4] = 0;
  }
}

async function generateMaze () {
  let stack = [];
  resetGrid();
  stack.push({ x: 0, y: 0 });
  while (stack.length) {
    let pos = stack.pop();
    let neighbors = getUnvisitedNeighbors(pos);
    if (neighbors.length) {
      let random = neighbors[Math.floor(Math.random() * 4)];
      let next = setVisited(pos, random);
      current = next.x + (next.y * 10);
      stack.push(next);
      await wait(50);
      $sync();
    }
  }
}
--

html [
  head[
    style "{{ styles }}"
  ]
  body root [
    div style="text-align:center;" [
      button on:click="generateMaze()" nosync "start"
    ]
    div.board [
      each (cell, i in grid) [
	div.cell class={[
	  cell[0] == 1 ? 'cell-top' : '',
	  cell[1] == 1 ? 'cell-right' : '',
	  cell[2] == 1 ? 'cell-bottom' : '',
	  cell[3] == 1 ? 'cell-left' : '',
	  cell[4] == 1 ? 'cell-visited' : '',
	  i == current ? 'cell-current' : ''
	]} []
      ]
    ]
  ]
]
